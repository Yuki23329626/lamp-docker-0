<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.0 [en] (Win95; I) [Netscape]">
   <TITLE>ans2</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#00FFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000" BACKGROUND="bg-slate.gif">

<H2>
<FONT COLOR="#0080FF">作業二</FONT></H2>

<UL>
<UL>
<H3>
<FONT COLOR="#FF0000">Due: 5/28/1997</FONT></H3>
</UL>
</UL>

<OL>
<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>乙太網路使用的通訊協定是1-persistent
CSMA，</FONT></FONT></B></LI>

<BR><B><FONT COLOR="#0000FF"><FONT SIZE=+1>有些研究人員覺得應該用p-persistent
CSMA，你覺得呢?</FONT></FONT></B>
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
　
<OL><B><FONT COLOR="#000000"><FONT SIZE=+1>以下只是僅供參考,可依個人看法作答即可:</FONT></FONT></B>
<BR><B><FONT COLOR="#000000"><FONT SIZE=+1>1-persistent是會一直去偵測網路是否為busy,直到不是busy狀態時就把封包丟出去，適合低負載的網路。p-persistant是以當網路不為busy時,以p的機率來傳封包,若為busy的話就等一個random</FONT></FONT></B>
<BR><B><FONT COLOR="#000000"><FONT SIZE=+1>wait,再來偵測是否為網路busy,適合高負載的網路.</FONT></FONT></B>
<BR><B><FONT COLOR="#000000"><FONT SIZE=+1>目前以ethernet大部分時間load還不是太重,所以覺得還是1-persistent可能是目前比較好的選擇.</FONT></FONT></B></OL>
<FONT COLOR="#000000">　</FONT>
<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>太網路的一個時槽是多少時間?這與最小frame長度有何關係?</FONT></FONT></B></LI>

<BR><B><FONT COLOR="#0000FF"><FONT SIZE=+1>在高速乙太網路中，時槽與最小frame長度有何改變?</FONT></FONT></B>
<BR>　
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
　
<OL><FONT SIZE=+1>(1)51.2μ sec</FONT>
<BR><FONT SIZE=+1>(2)因為要避免無法偵測到collision,所以最小fram 長度為51.2μ
* 10Mbps = 512 bits</FONT>
<BR><FONT SIZE=+1>(3)不變　</FONT>
<BR>　</OL>
　
<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>我們要如何使用sequence number, acknowledge,
timer, retransmission等方法來提供</FONT></FONT></B></LI>

<BR><B><FONT COLOR="#0000FF"><FONT SIZE=+1>完全可靠的傳輸(如IEEE 802.2的type
2 service)?</FONT></FONT></B>
<BR><B><FONT COLOR="#0000FF"><FONT SIZE=+1>這四種方法中，有那一個不一定要使用仍可以達到完全可靠的傳輸?</FONT></FONT></B>
<BR>　
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
　
<OL><FONT SIZE=+1>a. sequence number: 對每一個封包(packet)編號,如此可以知道是否重複收到同一個packet,並且可以確認收到每個封包的前後順序.</FONT>
<BR><FONT SIZE=+1>b.acknowledge:經由receiver將ack送給Sender的動作,sender可以確認receiver是否收到封包,如果沒有的話則必須重送,保證sender所送出的資料receiver一定會收到.</FONT>
<BR><FONT SIZE=+1>c.timer &amp; retransmission:當ack在傳送過程中遺失,或是因為receiver沒有收到packet,
所以sender必須設定一timer,若是time out的話, 就必須retransmission.</FONT>

<P><FONT SIZE=+1>此四種方法缺一不可才能保證傳輸的可靠性.</FONT></OL>
　
<BR>　
<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>以下情況下，GBN與SR那一個會表現比較好?</FONT></FONT></B></LI>

<BR><B><FONT COLOR="#0000FF"><FONT SIZE=+1>(你必須先決定以那些performance
metric來比較)</FONT></FONT></B>
<OL>
<LI>
<B><FONT COLOR="#8000FF"><FONT SIZE=+1>long propagation, no transmission
error</FONT></FONT></B></LI>

<LI>
<B><FONT COLOR="#8000FF"><FONT SIZE=+1>long propagation, moderate random
transmission error</FONT></FONT></B></LI>

<LI>
<B><FONT COLOR="#8000FF"><FONT SIZE=+1>burst transmission error</FONT></FONT></B></LI>

<BR>&nbsp;
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD>
<UL>
<LI>
<FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></LI>
</UL>
</TD>
</TR>
</TABLE>

<OL>
<LI>
<FONT SIZE=+1>　差不多</FONT></LI>

<LI>
<FONT SIZE=+1>SR,　 因為 僅需重送 lost 之　 packet.　 而 ＧＢＮ會重送太多本來就已經正確的packets.</FONT></LI>

<LI>
<FONT SIZE=+1>GBN, 因為 為burst transmission error,　 GBN,sender可一次就重送較多的資料
.</FONT></LI>

<BR><FONT SIZE=+1></FONT>&nbsp;
<BR>&nbsp;</OL>
</OL>

<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>如果使用n-bit sequence number，那麼SR與GBN的最大sending
window size是多少?試證明之。</FONT></FONT></B></LI>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
<B><FONT COLOR="#000000"><FONT SIZE=+1>(a) GBN=2<SUP>n</SUP>-1</FONT></FONT></B>
<OL><B><FONT SIZE=+1>說明:假設 n=3,則 sequence no 有 0 ~ 7</FONT></B>

<P><B><FONT SIZE=+1>(1) sender 送 frame 0~7 給 receiver</FONT></B>
<BR><B><FONT SIZE=+1>(2) receiver 回 ack 7</FONT></B>
<BR><B><FONT SIZE=+1>(3) sender 送 frame 0~7 給 receiver</FONT></B>
<BR><B><FONT SIZE=+1>(4) receiver 回 ack 7</FONT></B>
<BR><B><FONT SIZE=+1>若 (3) 中的 8 個封包全部遺失,則 sender 根本無法判斷</FONT></B>
<BR><B><FONT SIZE=+1>若一次只能傳 0~6 , 則 receiver 會回 ack 6 , 下次 sender
會送 7, 0~5, 而 receiver 會回 ack 5, 由</FONT></B>
<BR><B><FONT SIZE=+1>ack 的不同, sender 便可正確的判斷出來是否有遺失封包</FONT></B></OL>
<B><FONT SIZE=+1>(b) SR=2<SUP>n</SUP>-1</FONT></B>
<OL><B><FONT SIZE=+1>說明:假設N=3, 且receiver, sender 的 window size =5</FONT></B>
<BR><B><FONT SIZE=+1>(1) sender 送封包 0~4, receiver 都有正確收到, 其window便為
5,6,7,0,1 且回 ack 4</FONT></B>
<BR><B><FONT SIZE=+1>(2) if ack 4 loss, 則在 timeout 後 sender 會重送封包
0, 而 receiver 也剛好可以收 ( because 0 belong to { 5,6,7,0,1 })</FONT></B>
<BR><B><FONT SIZE=+1>此時 receiver 便重複收到相同的封包且不自知, 其後還會有更多問題.
(自己想)</FONT></B>

<P><B><FONT SIZE=+1>為確保上面的情形不會發生, 須規定 sender and receiver
的 window size 都是 2<SUP>n</SUP>/2, i.e 2<SUP>n-1 </SUP>彼此才不會重疊</FONT></B>
<BR>　
<BR>　</OL>

<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>Transparent bridge的功能包括那些?Transparent
bridge的過濾資料庫為什麼需要登錄時間?</FONT></FONT></B></LI>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
<B><FONT SIZE=+1>(1)</FONT></B>
<OL><B><FONT SIZE=+1>1. filtering</FONT></B>

<P><B><FONT SIZE=+1>2. forwarding</FONT></B>

<P><B><FONT SIZE=+1>3. 自動學習</FONT></B>

<P><B><FONT SIZE=+1>4. 過濾資料庫 (詳見 homepage)</FONT></B></OL>
<B><FONT SIZE=+1>(2)</FONT></B>
<OL><B><FONT SIZE=+1>因工作站是允許可以移動的，故隸屬的 port 也可能要修正，登錄時間表示這記錄已登錄</FONT></B>
<BR><B><FONT SIZE=+1>多久，而可利用此欄位來做定期的更新已避免在轉送資料時參考到過時而錯誤的資訊。</FONT></B></OL>

<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>舉例說明Transparent bridge的功能如果沒有spanning
tree 的演算法會造成何麼問題?下面的網路中，依spanning tree algorithm會形成怎樣的一個spanning
tree? (假設bridge到每一個區域網路的費用是1。)</FONT></FONT></B></LI>


<P><IMG SRC="hw2q7.gif" >
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
<B><FONT SIZE=+1>(1) 會有迴路(Loop)的問題產生(詳見 homepage)。</FONT></B>

<P><B><FONT SIZE=+1>(2) 　　　　1</FONT></B>
<BR><B><FONT SIZE=+1>　　　　 　/\\</FONT></B>
<BR><B><FONT SIZE=+1>　　　　　235</FONT></B>
<BR><B><FONT SIZE=+1>　　 　 　 /</FONT></B>
<BR><B><FONT SIZE=+1>　　 　　4</FONT></B>
<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>利用LS routing 找出下圖中F到其他router的最短路徑及其routing
rable 。</FONT></FONT></B></LI>


<P><IMG SRC="hw2q8.gif" >
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
　
<TABLE BORDER BGCOLOR="#FFFFFF" >
<TR VALIGN=BOTTOM>
<TD ALIGN=LEFT>step</TD>

<TD ALIGN=LEFT>N</TD>

<TD ALIGN=CENTER>D(A),P(A)</TD>

<TD ALIGN=CENTER>D(B),P(B)</TD>

<TD ALIGN=CENTER>D(C),P(C)</TD>

<TD ALIGN=CENTER>D(D),P(D)</TD>

<TD ALIGN=CENTER>D(E),P(E)</TD>

<TD ALIGN=CENTER>D(G),P(G)</TD>

<TD ALIGN=CENTER>D(H),P(H)</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>0</TD>

<TD ALIGN=LEFT>F</TD>

<TD ALIGN=CENTER>∞,-</TD>

<TD ALIGN=CENTER>∞,-</TD>

<TD ALIGN=CENTER>∞,-</TD>

<TD ALIGN=CENTER>3,F</TD>

<TD ALIGN=CENTER>1,F</TD>

<TD ALIGN=CENTER>6,F</TD>

<TD ALIGN=CENTER>∞,-</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>1</TD>

<TD ALIGN=LEFT>F,E</TD>

<TD ALIGN=CENTER>∞,-</TD>

<TD ALIGN=CENTER>∞,-</TD>

<TD ALIGN=CENTER>4,E</TD>

<TD ALIGN=CENTER>2,E</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>6,F</TD>

<TD ALIGN=CENTER>∞,-</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>2</TD>

<TD ALIGN=LEFT>F,E,D</TD>

<TD ALIGN=CENTER>∞,-</TD>

<TD ALIGN=CENTER>11,D</TD>

<TD ALIGN=CENTER>3,D</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>3,D</TD>

<TD ALIGN=CENTER>∞,-</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>3</TD>

<TD ALIGN=LEFT>F,E,D,C</TD>

<TD ALIGN=CENTER>7,C</TD>

<TD ALIGN=CENTER>5,C</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>3,D</TD>

<TD ALIGN=CENTER>∞,-</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>4</TD>

<TD ALIGN=LEFT>F,E,D,C,G</TD>

<TD ALIGN=CENTER>7,C</TD>

<TD ALIGN=CENTER>5,C</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>17,G</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>5</TD>

<TD ALIGN=LEFT>F,E,D,C,G,B</TD>

<TD ALIGN=CENTER>6,B</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>7,B</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>6</TD>

<TD ALIGN=LEFT>F,E,D,C,G,B,A</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>
</TR>

<TR VALIGN=BOTTOM>
<TD ALIGN=RIGHT>7</TD>

<TD ALIGN=LEFT>F,E,D,C,G,B,A,H</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>

<TD ALIGN=CENTER>　</TD>
</TR>
</TABLE>
<B><FONT COLOR="#FF8040"><FONT SIZE=+1>Routing table</FONT></FONT></B>
<TABLE BORDER BGCOLOR="#FFFFFF" >
<TR>
<TD>Dest</TD>

<TD>Next</TD>
</TR>

<TR>
<TD>A</TD>

<TD>E</TD>
</TR>

<TR>
<TD>B</TD>

<TD>E</TD>
</TR>

<TR>
<TD>C</TD>

<TD>E</TD>
</TR>

<TR>
<TD>D</TD>

<TD>E</TD>
</TR>

<TR>
<TD>G</TD>

<TD>E</TD>
</TR>

<TR>
<TD>H</TD>

<TD>E</TD>
</TR>
</TABLE>
　
<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>利用VD routing 找出下圖中E的distance
table及其routing rable (假設已經收斂了)。</FONT></FONT></B></LI>


<P><IMG SRC="hw2q9.gif" HEIGHT=175 WIDTH=282>
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
　
<TABLE BORDER BGCOLOR="#FFFFFF" >
<TR>
<TD>D<SUP>E</SUP></TD>

<TD>B</TD>

<TD>C</TD>

<TD>D</TD>
</TR>

<TR>
<TD>A</TD>

<TD>6</TD>

<TD>6</TD>

<TD>4</TD>
</TR>

<TR>
<TD>B</TD>

<TD>5</TD>

<TD>7</TD>

<TD>5</TD>
</TR>

<TR>
<TD>C</TD>

<TD>9</TD>

<TD>3</TD>

<TD>3</TD>
</TR>

<TR>
<TD>D</TD>

<TD>8</TD>

<TD>4</TD>

<TD>2</TD>
</TR>
</TABLE>
　
<TABLE BORDER BGCOLOR="#FFFFFF" >
<TR>
<TD>Dest</TD>

<TD>Next　</TD>
</TR>

<TR>
<TD>A</TD>

<TD>D</TD>
</TR>

<TR>
<TD>B</TD>

<TD>B</TD>
</TR>

<TR>
<TD>C</TD>

<TD>D</TD>
</TR>

<TR>
<TD>D</TD>

<TD>D</TD>
</TR>
</TABLE>
　
<LI>
<B><FONT COLOR="#0000FF"><FONT SIZE=+1>比較 LS routing 與 VD routing 的不同。VD
routing 會遇到什麼問題?如何解決?</FONT></FONT></B></LI>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Ans:</FONT></FONT></TD>
</TR>
</TABLE>
<B><FONT SIZE=+1>LS Routing 是屬於半集中式（quasi-centralized）的 routing
algo- rithm。</FONT></B>
<BR><B><FONT SIZE=+1>首先每個 router 必須定期地測量它與鄰近的 router 間的費用
（每兩個相鄰的 router 均有一鏈路將它們連起來，故有時我們也稱 此費用為鏈路費用（link
cost））。</FONT></B>
<BR><B><FONT SIZE=+1>此費用可能與 queueing　delay， bandwidth 等因素有關，依不同的
routing protocol</FONT></B>
<BR><B><FONT SIZE=+1>有不同的定義。 當每一 router 測得此鏈路費用後，便廣播給所有其他
router知道。</FONT></B>
<BR><B><FONT SIZE=+1>因每個 router 均定期廣播它所測得的鏈路費用，所以每個
router 也 定期地收到所有其他</FONT></B>
<BR><B><FONT SIZE=+1>router 送來的鏈路費用。當一個 router 收到所 有的鏈路費用後，它便有了全域資料</FONT></B>
<BR><B><FONT SIZE=+1>（global information），也就是 說它知道整個網路架構（拓樸）及網路裡每一條鏈路的費用。</FONT></B>
<BR><B><FONT SIZE=+1>這時 它便可利用找最短路徑的演算法來算出由它到其他每一個
router 的 最短路徑。也就是說它就可以更新（建立）它的　routing table 了。
在圖論中，</FONT></B>
<BR><B><FONT SIZE=+1>有許多找最短路徑的演算法，</FONT></B>
<BR><B><FONT SIZE=+1>其中我們最常用的是 Dijkstra's shortest path algorithm。</FONT></B>

<P><B><FONT SIZE=+1>LS Routing 是相當不經濟的方法，特別是網路很大時，</FONT></B>
<BR><B><FONT SIZE=+1>因為定期地廣播鏈路費用常會造成網路的壅塞（稱之為廣
播風暴（broadcast storm））</FONT></B>
<BR><B><FONT SIZE=+1>。所以在大範圍的網路中，我 們通常使用非同步-分散式的
routing algorithm，</FONT></B>
<BR><B><FONT SIZE=+1>稱為 vec- tor distance routing。在 VD routing algorithm，稱為
vector dis- tance routing。</FONT></B>
<BR><B><FONT SIZE=+1>在VD routing 中，每一 router 會在其鏈路費 用更動或
routing table 更動(因其他 router 之鏈路費用更動 造成）時，將其最新的 routing
table 告訴與它相鄰的 router （但它並不會將此資訊廣播）。</FONT></B>
<BR><B><FONT SIZE=+1>在每一個 router 上，它會 維持一個二維的 distance table
以記錄目前的 routing 資訊。</FONT></B>
<BR><B><FONT SIZE=+1>如果在網路上共有 N 個 router，而此 router 與 M 個
router 相鄰，</FONT></B>
<BR><B><FONT SIZE=+1>則它會維持一個 (N-1)×M 的 distance table。</FONT></B>
<BR><B><FONT SIZE=+1>我們可以使用 圖論中的分散式-非同步最短路徑演算法。</FONT></B>
<BR><B><FONT SIZE=+1>其中最常用的是 distributed Bellman-Ford algorithm</FONT></B>

<P><B><FONT SIZE=+1>　　VD routing 雖較適合大網路，但因其使用的是區域（local）
資訊（只有相鄰 router 之資訊），所以會造成以下兩個問題：</FONT></B>

<P><B><FONT SIZE=+1>(1)Looping：好消息傳的快，壞消息傳的慢。</FONT></B>

<P><B><FONT SIZE=+1>解決方法：最常用的方法有兩種：</FONT></B>
<OL><B><FONT SIZE=+1>(a) split horizon：</FONT></B>

<P><B><FONT SIZE=+1>A如果 D 到 A 的最短路徑是經由 E，則 D 必須告訴 E，</FONT></B>
<BR><B><FONT SIZE=+1>它到 A 的費用是無限大。</FONT></B>

<P><B><FONT SIZE=+1>(b) hold down：</FONT></B>

<P><B><FONT SIZE=+1>當最短路徑改變時，不要馬上反應給其他 router。</FONT></B></OL>
<B><FONT SIZE=+1>(2) Oscillations：當鏈路費用是以資料流量大小而定時，會造成最短路徑一直更動。</FONT></B>

<P><B><FONT SIZE=+1>解決方法：</FONT></B>
<OL><B><FONT SIZE=+1>(1) 不要定期地交換 routing 資訊</FONT></B>

<P><B><FONT SIZE=+1>(2) 不要讓鏈路費用與以流量大小成正比</FONT></B></OL>
</OL>

</BODY>
</HTML>
