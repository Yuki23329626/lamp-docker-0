<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE></TITLE>
   <META NAME="Author" CONTENT="">
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (Win95; I) [Netscape]">
</HEAD>
<BODY BACKGROUND="../../gif/bg-slate.gif">

<UL>
<UL>
<UL>
<P><IMG SRC="title.gif" HEIGHT=60 WIDTH=343></P>
</UL>
</UL>
</UL>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD COLSPAN="3"><B><FONT COLOR="#FFFFFF"><FONT SIZE=+2>流量控制　　　　　　　　　　　　　　　　　　</FONT></FONT></B></TD>
</TR>
</TABLE>

<UL>
<P><FONT SIZE=+1>　　流量控制的目的是為了調節送端與收端的速度，避免收端因<BR>
送端速度太快造成收端的 buffer overflow。</FONT></P>

<P><FONT SIZE=+1>流量控制的方法有以下二種：</FONT></P>

<P><FONT SIZE=+1>(1) Explicit Flow Control：</FONT></P>

<P><BR>
<FONT SIZE=+1>　　由收端定期或不定期地告訴送端其 buffer 還可以容納的packet<BR>
數量。送端收到此數量後 ， 必須改變其 sending window 在此數量<BR>
以下 。 （ ∵ sending window 包括送出去而還未 ACK 的 packet 及<BR>
尚可送的 packet 數量。）此種方法在TCP及ISO TP4中均有採用。</FONT></P>
</UL>

<P><BR>
<IMG SRC="expflow.gif" HEIGHT=226 WIDTH=629></P>

<UL>
<P><FONT SIZE=+1>(2) Implicit Flow Control：</FONT></P>

<P><FONT SIZE=+1>　　此方法不須收端送回其 buffer 大小，而是送端自行調節
send-<BR>
ing window 大小 。 每當送端收到目 前 sending window 的 第 一 個<BR>
ACK 時就將 window size 加大一倍 ， 但 若 在 time out 前 沒 收 到<BR>
ACK 則將 window size 減少 。IBM 的 virtual route pacing 採用此方<BR>
法 。 此 方法也類似下面將介紹的 window-based congestion control<BR>
的方法。</FONT></P>
</UL>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD COLSPAN="3"><B><FONT COLOR="#FFFFFF"><FONT SIZE=+2>壅塞控制　　　　　　　　　　　　　　　　　　</FONT></FONT></B></TD>
</TR>
</TABLE>

<UL>
<P><FONT SIZE=+1>　　也許收端的 buffer 還是有空，但因網路有太多 packet，造成<BR>
壅塞，此時送端仍須降低其傳送的速度。壅塞控制是非常重要的<BR>
工作，因許多童工可靠服務的傳輸層協定（如 TCP）在 ACK 未<BR>
在 time out 前回收的話 ， 會認定 packet lost 而進行重傳 。 如 果<BR>
ACK未收到是因網路壅塞而延誤，那麼重傳的動作不僅多此一舉<BR>
且造成更多的 packet 在網路中，網路也因而更擁擠。一個理想的<BR>
壅塞控制方法其 throughput 是與 offer load 成正比直到網路效能是<BR>
100%（如下圖所示），但由於種種因素（如重送）一個壅塞控制<BR>
方法很難達到此理想。</FONT></P>
</UL>

<P><IMG SRC="congestion.gif" HEIGHT=452 WIDTH=573></P>

<UL>
<P><FONT SIZE=+1>　　為避免 offered load 愈大，throughput 愈低，壅塞控制的方法<BR>
通常是避免太多、太快的重送。以下我們介紹四種方法：</FONT></P>

<UL>
<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1>Window-based
congestion control</FONT></P>

<P><FONT SIZE=+1>　　送端維持一個類似 sending window 的 congestion window<BR>
，所在尚未 ACK 的 packet 的 sequence number必須在此 con-<BR>
getstion window 內 （ 也就是說送端可以送出的 packet 的 se-<BR>
quence number 必須同時滿 足 flow control 的 sending window <BR>
及 congestion control 的 congestion window）。congestion win-<BR>
dow 會因網路壅塞情形而調整 。通常如果 ACK 正常收到會<BR>
調大 congestion window ， 若是發現 timeout，則會調小 con-<BR>
gestion window 且調大 timeout 值 ， 以避免太多太快的 time-<BR>
out 及重送。</FONT></P>

<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1>Network
indicated congestion control</FONT></P>

<P><FONT SIZE=+1>　　若網路發生壅塞（通常是指某一 router 的 buffer 大於某<BR>
一 threshold值），則網路層協定（軟體）可以採取以下兩種<BR>
方法：</FONT></P>

<UL>
<P><IMG SRC="../../gif/cy_ball.gif" HEIGHT=16 WIDTH=17><FONT SIZE=+1>Forward
Explicit Congestion Notification (FECN)</FONT></P>

<P><FONT SIZE=+1>　　將通過壅塞節點（ router ）的 packet 的 header中設<BR>
一個 congestion indication flag ， 當此 packet 到達收端時<BR>
， 收端便知道網路發生壅塞 ， 再由傳輸層協定決定如<BR>
何通知送端。ISO CLNP 與 ATM 均採用此方法。</FONT></P>

<P><IMG SRC="../../gif/cy_ball.gif" HEIGHT=16 WIDTH=17><FONT SIZE=+1>Backward
Explicit Congestion Notification (BECN)</FONT></P>

<P><FONT SIZE=+1>　　因發生壅塞時，主要是要讓送端知道而降低傳輸速<BR>
度，所以在 packet通過一壅塞的節點時最好是由此節點<BR>
送給送端一個“通知壅塞”的控制訊息（choke packet）<BR>
。ICMP 的 source quench（type=4，code = 0）就是用來<BR>
通知送端壅塞的控制訊息。</FONT></P>

<P><IMG SRC="becn.gif" HEIGHT=196 WIDTH=454></P>
</UL>

<P><FONT SIZE=+1>　　FECN 因需收端再通知送端，所以通常反應速度較慢。而<BR>
FECN 與 BECN 均需網路層協定的幫忙也破壞了原來 每 一 個<BR>
layer 是獨立自主的模組的的原則。</FONT></P>

<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1>Rate-based
source regulated congestion control</FONT></P>

<P><FONT SIZE=+1>　　在高速網路中（如 ATM ）要靠網路的 feedback 訊息來通<BR>
知送端網路壅塞在反應時間上均嫌太慢 。例如在 1 bits 的鏈路<BR>
上傳送一個 225 bytes 的 packet 只要 1 μsec。如果 feedback 訊<BR>
息要一秒才傳回送端，則此時送端可能以多送出一千萬個pack-<BR>
et 了。</FONT></P>

<P><FONT SIZE=+1>　　利用送端與收端在建立連線時便商量好傳送速率，則我們<BR>
可以利用 Leaky bucket 來控制送端送 packet 的速率在一定限制<BR>
以下。</FONT></P>

<UL>
<P><IMG SRC="lbucket.gif" HEIGHT=244 WIDTH=411></P>
</UL>

<P><FONT SIZE=+1>在 leaky bucket 中</FONT></P>

<UL>
<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>每一
packet 需拿到一 token 才可以送出<BR>
<IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14>token 產生速率是 r，這也是送端送
packet 的平均速率<BR>
<IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14>token 沒有用的可以先存在
token bucket 中但此 bucket<BR>
　最多只能存 b 個 tokens<BR>
<IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14>在時間 [t, t+a] 中最多只能送
b+ra 的 packet</FONT></P>
</UL>

<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1>Congestion
Control by Buffer Preallocation</FONT></P>

<P><FONT SIZE=+1>　　壅塞的發生是因為 buffer 太滿了，所以要避免壅塞可以<BR>
從 buffer 著手。這個方法是在送端與收端建連線時，就在其<BR>
路徑上的每一個節點的 buffer 均預留固定的空間給這連線使<BR>
用。如此，只需送端依事先約定的速率傳送，每個節點上的<BR>
buffer 不會因其他連線的影響而不夠用。此方法最大的優點<BR>
是連線間不會互相干擾，大量送資料的連線只會造成自己壅<BR>
塞 ， 不會影響別的連線 。此方法的缺點是缺乏 multiplexing<BR>
gain，造成網路效能較低。</FONT></P>

<UL>
<P><FONT SIZE=+1>　　</FONT></P>
</UL>
</UL>
</UL>

</BODY>
</HTML>
