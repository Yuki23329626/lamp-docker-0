<HTML>
<BODY >

<P></P><A HREF="JavaScript:parent.ItemClicked(1, 0)"> Client and Server Model </A><br><UL>
<LI>Client
<UL>
<LI>an application that initiates peer-to-peer communication
</UL></UL><UL>
<LI>Server
<UL>
<LI>a program that waits for communication requests from a client
<LI>TCP/IP does not provide any mechansim that automatically create running program when a message arrives
<LI>server must be waiting to accept requests</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(2, 0)"> Client and Server Model </A><br><UL>
<LI>Privilege and Complesity
<UL>
<LI>server usually requires system privileges
<UL>
<LI>handles authentication, authorization, data security, privacy, protection
</UL><LI>server needs to handle request concurrently
<LI>servers are usually more difficult to design and implement
</UL></UL><UL>
<LI>Parameterization of client
<UL>
<LI>client should provide user interface to specify which server and which port number to connect to</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(3, 0)"> Client and Server Model </A><br><UL>
<LI>Connection oriented vs connectionless
<UL>
<LI>reliability is the issue
<LI>use TCP unless the application requires broadcast, multicast, or connot tolerate virtual circuit overhead
</UL></UL><UL>
<LI>Stateless vs stateful
<UL>
<LI>keeping a small amount of information in a server can reduce the size of message that the client and server exchange and allow server to respond quickly (e.g., ftp client reads blocks of a large file)</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(4, 0)"> Client and Server Model </A><br><UL>
<LI>Stateless vs stateful (cont.)
<UL>
<LI>however state information in a server may become incorrect if messages are lost, duplicated, out of order, or the client crashes and rebootss
<LI>if underlying network is not reliable, state information is very difficult to maintain correctly. That is, for internet (IP network), a stateless server is preferred.</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(5, 0)"> Concurrent Issues </A><br><UL>
<LI>The network itself provides currency
<UL>
<LI>many connections coexist simultaneously
</UL></UL><UL>
<LI>Most client software does not require concurrency design
<UL>
<LI>OS provides the concurrency
<LI>user can run the same program more than once
</UL></UL><UL>
<LI>Server programs usually need to provide concurrency such that it can handle incoming requests concurrently</UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(6, 0)"> Concurrent Issues </A><br><UL>
<LI>In UNIX, use fork( ) to create a child process
<UL>
<LI>return 0 for child
<UL>
<LI>execve( ) to execute an new code
</UL><LI>return child id for parent
<LI>Note the overhead of context switch
</UL></UL><UL>
<LI>Asynchronous I/O
<UL>
<LI>a process controls concurrent input and output operations
<LI>select
<LI>signal</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(7, 0)"> Client Software Design </A><br><UL>
<LI>Allow user to specify server address
<UL>
<LI>more general
<LI>some application may just use different servers (e.g., time)
<LI>how to know the user specifies a name ore an IP address?
<UL>
<LI>test if the address contains alphabetic characters
</UL><LI>how to specify port number
<UL>
<LI>client servname port (telnet)
<LI>client servname:port (http)</UL></UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(8, 0)"> Client Software Design </A><br><UL>
<LI>Convert address to binary format
<UL>
<LI>inet_addr(ip_address)
<UL>
<LI>convert ip address (140.123.101.100) to Internet address (32 bits, network order)
</UL><LI>gethostbyname(hostname)
<UL>
<LI>convert hostname(cs.ccu.edu.tw) to Internet address
</UL>#include &#060netdb.h&#062
<BR>struct hostent {
<BR>       char    *h_name;        /* official name of host */
<BR>        char    **h_aliases;    /* alias list */
<BR>        int     h_addrtype;     /* host address type */
<BR>        int     h_length;       /* length of address */
<BR>        char    **h_addr_list;  /* list of addresses from            					name server */
<BR>#define h_addr  h_addr_list[0]  /* address, for backward compatiblity */
<BR>};</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(9, 0)"> example
 </A><br><UL>
<LI>example
<BR>char *hostname = “cs.ccu.edu.tw”;
<BR>if (hptr = gethostbyname(hostname)){
<BR>    memcpy(&sin.sin_addr, hptr-&#062h_addr, hptr-&#062h_length);
<BR>}
</UL><UL>
<LI>Automatically get default port number
<UL>
#include &#060netdb.h&#062
<BR><BR>struct  servent {
<BR>        char    *s_name;        /* official service name */
<BR>        char    **s_aliases;    /* alias list */
<BR>        int     s_port;         /* port # */
<BR>        char    *s_proto;       /* protocol to use */
<BR>};
<BR>
<BR>struct servent *sptr;
<BR>if (sptr = getservbyname(“smtp”, “tcp”)) {
<BR>    sin.sin_port = sptr-&#062s_port;
<BR>}</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(10, 0)"> Automatically get protocol number
 </A><br><UL>
<LI>Automatically get protocol number
<UL>
#include &#060netdb.h&#062
<BR><BR>struct  protoent {
<BR>        char    *p_name;        /* official protocol name */
<BR>        char    **p_aliases;    /* alias list */
<BR>        int     p_proto;        /* protocol # */
<BR>};
<BR>struct protoent *pptr;
<BR>if (pptr=getprotobyname(“udp”))
<BR>    return pptr-&#062p_proto;</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(11, 0)"> Algorithm for Client (TCP) </A><br><UL>
<LI>Find Server’s IP and port number
</UL><UL>
<LI>Open socket (socket())
</UL><UL>
<LI>choose local port number
</UL><UL>
<LI>connect to server (connect())
</UL><UL>
<LI>Send request/Wait for reply
</UL><UL>
<LI>Close connection
<UL>
<LI>shutdown(sock, direction)
<LI>direction=0: no further input
<LI>direction=1: no further output
<LI>direction=2: neither</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(12, 0)"> Algorithm for Client (UDP) </A><br><UL>
<LI>Find Server’s IP and port number
</UL><UL>
<LI>Open socket (socket())
</UL><UL>
<LI>Choose local port number
</UL><UL>
<LI>Specify server
<UL>
<LI>can use connect()
</UL></UL><UL>
<LI>Send request/Wait for reply
</UL><UL>
<LI>Close connection</UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(13, 0)"> Server Software Design </A><br><UL>
<LI>Iterative vs concurrent
<UL>
<LI>Iterative: esay, little overhead
<LI>concurrent: 
<UL>
<LI>better performance (e.g., client’s average response time)
<LI>a request may require significant I/O
<LI>processing time required by a request varies dramatically
<LI>server runs on a computer with multiple processors
</UL></UL></UL><UL>
<LI>Connection-oriented vs connectionless
<UL>
<LI>Application protocol decides the choice</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(14, 0)"> connection-oriented
 </A><br><UL>
<LI>connection-oriented
<UL>
<LI>ease of programming due to underlying reliable transmission (no loss, in-order, connection broken informed)
<LI>disadvantages
<UL>
<LI>more resources: separate socket, connection, data structures
<LI>overhead: 3-way handshaking for connection establishment/ termination
<LI>hard to detect client crash, resource cannot be reclaimed ASAP
</UL><LI>Connectionless
<UL>
<LI>How to ensure reliable transmission
<UL>
<LI>usually clients take the responsibility for retransmission
<LI>server may need retransmission if reply consists of multiple packets
</UL><LI>difficult to achieve reliable transmission if UDP is used
<LI>supports multicast</UL></UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(15, 0)"> Optimizing stateless server
 </A><br><UL>
<LI>Optimizing stateless server
<UL>
<LI>when doing optimization, be careful not to introduce state information
</UL></UL><UL>
<LI>Four types of servers
<UL>
<LI>iterative / concurrent
<LI>connection-oriented / connectionless
</UL></UL><UL>
<LI>Master/Slave processes
<UL>
<LI>master waits for request (parent process)
<LI>slave processes the request (child process)</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(16, 0)"> Iterative, Connection- oriented Server </A><br><UL>
<LI>Create a socket and bind to a well-known address
</UL><UL>
<LI>Place the socket in passive mode
</UL><UL>
<LI>Accept the next connection, obtain new socket id
</UL><UL>
<LI>Repeatedly read a request from the client, process it, and reply
</UL><UL>
<LI>When finished, close the connection and return to step 3</UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(17, 0)"> Iterative, Connectionless Server </A><br><UL>
<LI>Create a socket and bind to a well-known address
</UL><UL>
<LI>Repeatedly read the next request, process it, and reply back to the client</UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(18, 0)"> Concurrent, Connectionless Server </A><br><UL>
<LI>Master
<UL>
<LI>Create a socket and bind to well-known address (unconnected)
<LI>Repeatedly call recvfrom( ) to receive a request and create a new slave process to handle it
</UL></UL><UL>
<LI>Slave
<UL>
<LI>Receive the request upon creation
<LI>Form a reply and call sendto( )
<LI>Exit</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(19, 0)"> Concurrent, Connection- oriented Server </A><br><UL>
<LI>Master
<UL>
<LI>Create a socket and bind to a well-known address
<LI>Place the socket in passive mode
<LI>Accept the next connection, create a new slave process to handle it
</UL></UL><UL>
<LI>Slave
<UL>
<LI>Receive a socket id upon creation
<LI>Interact with the client with read (recv) and write(send)
<LI>Close the socket and exit</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(20, 0)"> Apparent Concurrency Using select </A><br><UL>
<LI>Create a socket and bind to a well-known address
</UL><UL>
<LI>Use select to wait for I/O on existing sockets
</UL><UL>
<LI>Use accept to obtain the next connection, add the new socket to the list on which select waits for
</UL><UL>
<LI>Use read(recv) / write (send) to interact with clients
</UL><UL>
<LI>Continue processing with step 2</UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(21, 0)"> Multiprotocol Servers </A><br><UL>
<LI>Many trivial services can be accessed through either TCP or UDP
<UL>
<LI>share most of the codes
<LI>avoid too many server programs
<LI>reduce system resource requirement
<LI>easy to debug (need not to do twice)</UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(22, 0)"> Multiservice Server(Super Server) </A><br><UL>
<LI>Have a server serves many simple services (TIME, ECHO,...)
</UL><UL>
<LI>Connection-oriented 
<UL>
<LI>one socket per service
</UL></UL><UL>
<LI>Connectionless
<UL>
<LI>one socket per service
<LI>new socket for each request
<LI>concurrent: a slave for a request
<LI>slave executes different program
<UL>
<LI>execve( ) in UNIX
</UL></UL></UL><UL>
<LI>Configurable super server
<UL>
<LI>static: configuration file
<LI>dynamic: redefines service without restarting
<UL>
<LI>how to inform the server? 
<UL>
<LI>singal
<LI>socket for control </UL></UL></UL></UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(23, 0)"> UNIX Super Server, inetd </A><br><UL>
<LI>A single process offers many services
</UL><UL>
<LI>Two configuration files
<UL>
<LI>/etc/services
<UL>
<LI>define service name, port, protocol
<BR>echo            7/tcp
<BR>echo            7/udp
<BR>daytime         13/tcp
<BR>daytime         13/udp
<BR>ftp             21/tcp
<BR>telnet          23/tcp
<BR>smtp            25/tcp 
</UL><LI>/etc/inetd.conf
<UL>
<LI>define which program to run
<LI>syntax
<BR>&#060service_name&#062 &#060socket_type&#062 &#060proto&#062 &#060flags&#062 &#060user&#062 &#060server_pathname&#062 &#060args&#062
</UL></UL></UL><UL>
          ftp stream tcp nowait  root  /usr/etc/tcpd  in.ftpd</UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(24, 0)"> PowerPoint 簡報 </A><br><UL>
socket( )
</UL><UL>
bind( )
</UL><UL>
listen( )</UL></P>
<P><UL>
select( )</UL></P>
<P><UL>
accept( )
</UL><UL>

</UL><UL>
fork( )</UL></P>
<P><UL>
close socket
</UL><UL>
(if stream)</UL></P>
<P><UL>
1. close all files other 
</UL><UL>
    than the socket
</UL><UL>
2. dup2( ) copy 
</UL><UL>
    socket to fd 0,1,2
</UL><UL>
3. setgid( ), setuid( )
</UL><UL>
4. execv( )
</UL><UL>
5. exit( ) when done</UL></P>
<P><UL>
remove the socket
</UL><UL>
from the select
</UL><UL>
list if wait flag
</UL><UL>
is specified</UL></P>
<P><UL>
if wait flag is set,
</UL><UL>
parent will catch the
</UL><UL>
SIGCLD signal and
</UL><UL>
add the socket to 
</UL><UL>
select list again</UL></P>
<P><UL>
parent</UL></P>
<P><UL>
child</UL></P>
<P><UL>
a socket is created
</UL><UL>
for each service</UL></P>
<P>
<P></P><A HREF="JavaScript:parent.ItemClicked(25, 0)"> More on Concurrent Server </A><br><UL>
<LI>Demand-driven concurrency
<UL>
<LI>dealy for creating a process for each request
</UL></UL><UL>
<LI>Process preallocation
<UL>
<LI>connection-oriented server
<UL>
<LI>master process preallocates N slaves
<LI>slaves call accept( )
<LI>exactly one slave will serve one request (on a new socket)
</UL><LI>connectionless server
<UL>
<LI>master process preallocates N slaves
<LI>slaves call recvfrom( )
<LI>exactly one slave will serve one request
</UL></UL></UL><UL>
<LI>Delayed process allocation
<UL>
<LI>a server begins processing each request iteratively
<LI>the server creates a concurrent process when processing time becomes too long</UL></UL></P>
<P>
</BODY>
</HTML>