<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE></TITLE>
   <META NAME="Author" CONTENT="">
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (Win95; I) [Netscape]">
</HEAD>
<BODY BACKGROUND="../../gif/bg-slate.gif">

<P><FONT COLOR="#0080FF"><FONT SIZE=+3>媒體存取控制子層</FONT></FONT></P>

<P><FONT COLOR="#FF0000"><FONT SIZE=+2>封包的觀念</FONT></FONT></P>

<P><FONT SIZE=+1>　　通常電腦在將資料傳到電腦網路上時，會先將資料（例如一個檔案）<BR>
切割成一個一個的小封包。為什麼呢？主要有兩個原因：</FONT></P>

<OL>
<LI><FONT SIZE=+1>資料在傳送過程中有可能發生錯誤。如果沒有分成一個一個的小封包<BR>
，比較難進行流量控制及錯誤處理（例如哪一個位元傳錯了）。</FONT></LI>

<LI><FONT SIZE=+1>在區域網路中，傳輸媒體是共用的，如果資料不先切成一小塊一小塊<BR>
，那麼如果有一電腦佔用傳輸媒體後，傳送一個很大的檔，將造成其<BR>
他電腦必須等很久。</FONT></LI>
</OL>

<P><IMG SRC="../../gif/bar.gif" HEIGHT=20 WIDTH=600></P>

<P><FONT COLOR="#FF0000"><FONT SIZE=+2>封包與框</FONT></FONT></P>

<P><FONT SIZE=+1>　　封包是一個通俗的概念，當媒體存取控制子層準備好一個封包要往傳<BR>
輸媒體上送時，我們通常稱為框（ Frame ）。為了讓收端可以辨識一個框<BR>
，送端會在資料前後分別加上框頭記號及框尾記號。通常我們可以用兩種<BR>
技術來作框頭及框尾記號。一是以字元組為主（ byte-oriented ）另一是以<BR>
字元為主（ bit-oriented ）。以字元為主時，我們可以選擇某一特殊字元當<BR>
框頭另一字元當框尾。例如以 ASCII code 中之 soh ( 0x01) 及 eot (0x04) 分<BR>
別為框頭及框尾。</FONT></P>

<UL>
<P><IMG SRC="F5_3.gif" HEIGHT=123 WIDTH=499></P>
</UL>

<P><FONT SIZE=+1>利用特殊記號當框頭及框尾時，有可能在資料中也會出現與此兩記號完全<BR>
相同的情形。如果發生這種情形，電腦可能錯將資料當成框頭或框尾記號<BR>
。為解決這個問題，我們可以依字元為主會位元為主分別進行 byte stuffing<BR>
及 bit stuffing。例如資料中如果出現 soh 或 eot 時，我們必須以逸出碼（ESC<BR>
）加另一碼代替，如下表所示：</FONT></P>

<UL>
<UL>
<UL>
<P><IMG SRC="F5_4.gif" HEIGHT=203 WIDTH=316></P>
</UL>
</UL>
</UL>

<P><FONT SIZE=+1>我們以下圖說明資料經過 byte stuffing 之後的結果：</FONT></P>

<UL>
<P><IMG SRC="F5_5.gif" HEIGHT=215 WIDTH=500></P>
</UL>

<P><IMG SRC="../../gif/bar.gif" HEIGHT=20 WIDTH=600></P>

<P><FONT COLOR="#FF0000"><FONT SIZE=+2>錯誤偵測</FONT></FONT></P>

<P><FONT SIZE=+1>　　電壓的不穩、磁場的干擾，…等均可能使訊號在媒體上傳輸時被改變<BR>
而造成資料接收錯誤。所以媒體存取控制層在接收到一個 frame 時，必須<BR>
做錯誤偵測。錯誤偵測的方法有下列幾種：</FONT></P>

<UL>
<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1><FONT COLOR="#0000FF">利用同位位元</FONT>：可以利用奇同位位元或偶同位位元來檢查。奇同位<BR>
　元是利用一多餘的位元使資料中所有位元和是奇數。（偶同位位元<BR>
　則是偶數）。RS-232即是利用此方法。但此方法無法偵測偶數個位<BR>
　元發生錯誤的情形。</FONT></P>

<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1><FONT COLOR="#0000FF">利用
checksum</FONT>：為改進同位位元的不足，我們可以利用 16-bit 或 32-<BR>
　bit 的 checksum 來作錯誤檢查。首先我們將資料分成數個 16-bit（或<BR>
　32-bit）的整數（不管原來資料是字元或數字）。再將它們全部加在<BR>
　一起（進位也加到最後結果中）。下圖說明 16-bit checksum的做法：</FONT></P>

<UL>
<P><IMG SRC="F5_6.gif" HEIGHT=160 WIDTH=499></P>
</UL>

<P>　<FONT SIZE=+1>利用 checksum 還是有偵測不到之錯誤，如下圖所示：</FONT></P>

<UL>
<P><IMG SRC="F5_7.gif" HEIGHT=242 WIDTH=501></P>
</UL>

<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1>利用
Cyclic Redundance Checks (CRC)<BR>
　大部分網路系統利用 CRC 來偵測更多的錯誤。<BR>
　CRC 的做法是：</FONT></P>

<UL>
<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1>將 n-bits
之資料視為 (n-1) 次方之多項式 <I>M(x)</I> 之係數 </FONT></P>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1>將 k-bits
之 FCS , <I>F(x)</I> 放在原資料後面 </FONT></P>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1><I>T(x)</I>
為 (n+k) bits 之傳送資料 </FONT></P>

<UL>
<P><I><FONT SIZE=+2>T(x) = x<SUP>k</SUP>M(x) + F(x)</FONT></I></P>
</UL>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1><I>G(x)</I>
為 (k+1) bits 之 generator </FONT></P>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1><I>F(x)</I>
之決定 </FONT></P>

<UL>
<P><IMG SRC="IMG00002.GIF"><FONT SIZE=+1> </FONT></P>

<P><FONT SIZE=+1>Let </FONT><I><FONT SIZE=+2>T(x) = x<SUP>k</SUP>M(x) +
R(x)</FONT></I></P>

<P><FONT SIZE=+1>則　<IMG SRC="IMG00004.GIF" ALIGN=ABSCENTER>
</FONT></P>

<UL>
<P><IMG SRC="IMG00005.GIF"><FONT SIZE=+1> </FONT></P>

<P><IMG SRC="IMG00006.GIF"><FONT SIZE=+1> </FONT></P>
</UL>

<P><FONT SIZE=+1>∴ <I>F(x)</I> 即為 <I>x<SUP>k</SUP>M(x)</I> 除以 <I>G(x)</I>
之餘數 </FONT><BR>
</P>
</UL>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1>例子：</FONT></P>

<UL>
<P><FONT SIZE=+2><I>M</I>=1010001101<BR>
<I>G</I>=110101<BR>
FCS is 5 bits<BR>
<I>x<SUP>k</SUP>M </I>= 101000110100000<BR>
<I>x<SUP>k</SUP>M/G</I>=1101010110+<IMG SRC="Img00010.gif" HEIGHT=64 WIDTH=58 ALIGN=ABSCENTER><BR>
→<I>R</I>=01110<BR>
<I>T</I>=101000110101110</FONT></P>
</UL>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1>CRC 特點：</FONT></P>

<UL>
<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>可偵測出
1 bit 的錯誤。</FONT></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>如果
<I>F(x)</I> 中 3 項以上的因式，則可偵測出 2 bits 的錯誤。</FONT></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>如果
<I>F(x)</I> 含有 (x + 1) 的因式，則可偵測出奇數個的錯誤。</FONT></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>可偵測出長度比
FCS 小的連續錯誤。</FONT></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>可偵測出大部分較長的連續錯誤。</FONT></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>無法偵測出資料前頭或尾被加入一串零的錯誤。</FONT></P>
</UL>
</UL>
</UL>

<P><IMG SRC="../../gif/bar.gif" HEIGHT=20 WIDTH=600></P>

<P><FONT COLOR="#FF0000"><FONT SIZE=+2>IEEE 802 標準所用之 CRC</FONT></FONT></P>

<P><FONT SIZE=+1>　　上述 CRC 方法無法偵測資料頭尾被加入一串零的錯誤。（想想看為什<BR>
麼？）所以 IEEE 802 將之修改為：</FONT></P>

<UL>
<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><B><I><FONT SIZE=+1>G(x)
= x<SUP>32</SUP> + x<SUP>26</SUP> + x<SUP>23</SUP> + x<SUP>22</SUP> + x<SUP>16</SUP>
+ x<SUP>12</SUP> + x<SUP>11</SUP> + x<SUP>10<BR>
</SUP>　　　+ x<SUP>8</SUP> + x<SUP>7</SUP> + x<SUP>5</SUP> + x<SUP>4</SUP>
+ x<SUP>2</SUP> + x+ 1</FONT></I></B></P>
</UL>

<UL>
<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><I><FONT SIZE=+1><B>R(x)
= </B>[<B> x<SUP>32</SUP>M(x) + x<SUP>n</SUP>L(x)</B>]</FONT><FONT SIZE=+2>/</FONT><B><FONT SIZE=+1>G(x)</FONT></B></I></P>

<P><B><I><FONT SIZE=+1>　where L(x) = x<SUP>31</SUP> + x<SUP>30</SUP> +
x<SUP>29</SUP> + .......+ 1</FONT></I></B></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>事實上是將<I>M(x)</I>最前面32
bits做補數運算 </FONT></P>

<P><FONT SIZE=+1>　用途：解決erronous leading zeros之問題 </FONT></P>

<P><FONT SIZE=+1>　將<I>G(x)</I>做補數運算即為FCS碼，用意是detect erronous
trailing zeros. </FONT></P>

<P><FONT SIZE=+1>　假如沒有傳輸錯誤，<I>T</I>(<I>x</I>)/<I>G</I>(<I>x</I>)
= 1100 0111 0000 0100<BR>
　　　　　　　　　　　　　　　1101 1101 0111 1011 </FONT></P>
</UL>

<P><IMG SRC="../../gif/bar.gif" HEIGHT=20 WIDTH=600></P>

<P><FONT COLOR="#FF0000"><FONT SIZE=+2>利用硬體來計算 CRC</FONT></FONT></P>

<P><FONT SIZE=+1>　　只需要 shift register 及 XOR unit，就可以很容易地計算出
CRC 喔！下<BR>
個展示 CRC-16 ( <B><I>G(x) = x<SUP>16</SUP> + x<SUP>11</SUP> + x<SUP>4</SUP>
+ 1</I></B><I> </I>)的做法。</FONT></P>

<UL>
<P><IMG SRC="F5_10.gif" HEIGHT=170 WIDTH=501></P>
</UL>

<P><FONT SIZE=+1>此 CRC 可以偵測出：</FONT></P>

<OL>
<LI><FONT SIZE=+1>所有 1-bit 及 2-bit 錯誤</FONT></LI>

<LI><FONT SIZE=+1>所有奇數個位元錯誤</FONT></LI>

<LI><FONT SIZE=+1>所有長度小於或等於 16 之連續錯誤（burst error）</FONT></LI>

<LI><FONT SIZE=+1>99.997% 之機率可以偵測出長度 17 之連續錯誤</FONT></LI>

<LI><FONT SIZE=+1>99.998% 之機率可以偵測出長度 18 之連續錯誤</FONT></LI>
</OL>

<P><IMG SRC="../../gif/bar.gif" HEIGHT=20 WIDTH=600></P>

<P><FONT COLOR="#FF0000"><FONT SIZE=+2>框頭框尾與錯誤檢查</FONT></FONT></P>

<UL>
<P><IMG SRC="F5_11.gif" HEIGHT=122 WIDTH=500></P>
</UL>

<CENTER>
<P>
<A HREF="../intro/intro.htm" BORDER="0">
<IMG SRC="../../gif/up.jpg" BORDER=0 ></A>
<A HREF="../lan/lan.htm" BORDER="0">
<IMG SRC="../../gif/down.jpg" BORDER=0 ></A>
</P>
</CENTER>

</BODY>
</HTML>
