<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE></TITLE>
   <META NAME="Author" CONTENT="">
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (Win95; I) [Netscape]">
</HEAD>
<BODY BACKGROUND="../../gif/bg-slate.gif">
<UL>
<UL>
<UL>
<P><IMG SRC="title.gif" HEIGHT=60 WIDTH=343></P>
</UL>
</UL>
</UL>
<TABLE BGCOLOR="#FF0000" >
<TR>
<TD COLSPAN="3"><B><FONT COLOR="#FFFFFF"><FONT SIZE=+2>何謂路徑選擇　　　　　　　　　　　　　　　　</FONT></FONT></B></TD>
</TR>
</TABLE>

<UL>
<P><FONT SIZE=+1>　　要將許多區域網路連成廣域網路時，必須透過一種網路連結<BR>
設備，我們稱之為 router （或 packet switch ）。router 和 bridge <BR>
最大的不同是 router 所處理的是網路層的封包與協定而 bridge 則<BR>
是處理資料鏈結層。所以 router 的工作是做路徑選擇與轉送 （<BR>
store-and-forward） 。</FONT></P>

<P><IMG SRC="F10_2.gif" HEIGHT=291 WIDTH=500></P>

<P><FONT SIZE=+1>　　Router 的工作是很單純的，每當一封包由某一輸入埠（input<BR>
port）進來後，router 便依封包目的地位址去查它的 routing　table，<BR>
得知此封包應由哪一輸出埠（output　port）輸出後，便將封包送<BR>
至此輸出埠。通常此輸出埠會連接另一　 router ，此封包便經由<BR>
此輸出埠轉送至路徑上的下一個 router 。所以我們又稱此種 rout-<BR>
ing 方式為 next-hop routing。</FONT></P>

<P><IMG SRC="F10_4.gif" HEIGHT=241 WIDTH=499></P>

<P><IMG SRC="F10_6.gif" HEIGHT=196 WIDTH=501></P>

<P><IMG SRC="F10_7.gif" HEIGHT=195 WIDTH=498></P>

<P><FONT SIZE=+1>　　從上述說明看來，router 的工作似乎是很簡單，問題是
routing<BR>
table 如何建立和更新呢？事實上，routing table 的維護是 router 最<BR>
重要也最複雜的工作之一。它是靠 routing protocol 中的 routing algo-<BR>
rithm 來達成。由於廣域網路連接許多的異質網路 （heterogeneous<BR>
networks），所以 routing algorithm 必須是 scable, robust（safe, fault-<BR>
tolerant），有好的效能 （high utilization, low delay 等），並支援服<BR>
務品質保證。</FONT></P>
<A HREF="router1.mov">Router 動畫範例 1</A>(
<A HREF="../../../software/qt32inst.exe">QuickTime Format</A>)<BR>
<A HREF="router2.mov">Router 動畫範例 2</A>(
<A HREF="../../../software/qt32inst.exe">QuickTime Format</A>)
</UL>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD COLSPAN="3"><B><FONT COLOR="#FFFFFF"><FONT SIZE=+2>路徑選擇演算法　　　　　　　　　　　　　　　</FONT></FONT></B></TD>
</TR>
</TABLE>

<UL>
<P><FONT SIZE=+1>　　目前在 Internet 上最常使用的路徑選擇演算法分為兩大類：<BR>
Link-State （LS） Routing 與 Vector Distance （VD） Routing。兩<BR>
者最大的差別是使用的資訊是全域（global）或區域 （local）。</FONT></P>

<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><B><FONT SIZE=+1>LS
Routing</FONT></B></P>

<P><FONT SIZE=+1>　　LS Routing 是屬於半集中式（quasi-centralized）的 routing
algo-<BR>
rithm。首先每個 router 必須定期地測量它與鄰近的 router 間的費用<BR>
（每兩個相鄰的 router 均有一鏈路將它們連起來，故有時我們也稱<BR>
此費用為鏈路費用（link cost））。此費用可能與 queueing　delay，<BR>
bandwidth 等因素有關，依不同的 routing 　protocol 有不同的定義。<BR>
當每一 router 測得此鏈路費用後，便廣播給所有其他　router知道。<BR>
因每個 router 均定期廣播它所測得的鏈路費用，所以每個 router 也<BR>
定期地收到所有其他 router 送來的鏈路費用。當一個 router 收到所<BR>
有的鏈路費用後，它便有了全域資料（global information），也就是<BR>
說它知道整個網路架構（拓樸）及網路裡每一條鏈路的費用。這時<BR>
它便可利用找最短路徑的演算法來算出由它到其他每一個 router 的<BR>
最短路徑。也就是說它就可以更新（建立）它的　routing table 了。<BR>
在圖論中，有許多找最短路徑的演算法，其中我們最常用的是<BR>
Dijkstra's shortest path algorithm。</FONT></P>

<P><B><FONT SIZE=+1>　<IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19>Dijkstra's
algorithm</FONT></B></P>

<UL>
<P><FONT SIZE=+1>Define:</FONT></P>
</UL>
</UL>

<UL>
<UL>
<UL>
<P><FONT SIZE=+1>N: set of all nodes such that shortest path from source
to these <BR>
　nodes isknown. N initially empty.</FONT></P>

<P><FONT SIZE=+1>D(v): cost of known least cost path from source to v.</FONT></P>

<P><FONT SIZE=+1>c(i,j): cost of link i-j, c(i,j) = ∞ if i,j not directly
connected.</FONT></P>

<P><FONT SIZE=+1>p(v): previous node (neighbor of v) along shortest path
from <BR>
　　source to v.</FONT></P>
</UL>

<P><FONT SIZE=+1>Algorithm:</FONT></P>

<UL>
<P><FONT SIZE=+1>source node: A<BR>
iterative: after k steps know shortest path to nearest k neighbors</FONT></P>

<P><FONT SIZE=+1>(1) Initialization:</FONT></P>

<UL>
<P><TT><FONT SIZE=+1>N = {A}<BR>
for all nodes v<BR>
　if v adjacent to A<BR>
　　then D(v) = c(A,v)<BR>
　else D(v) = ∞</FONT></TT></P>
</UL>

<P><FONT SIZE=+1>(2) <B>Loop<BR>
</B>　　　<TT>find w not in N such that D(w) is smallest<BR>
　　　add w into N<BR>
　　　update D(v) for all v not in N:<BR>
　　　　D(v) = min(D(v), D(w)+c(w,v))<BR>
</TT>　 <B>until </B>all nodes in N</FONT><BR>
</P>
</UL>

<P><FONT SIZE=+1>Example:</FONT></P>

<P><IMG SRC="example.gif" HEIGHT=250 WIDTH=400></P>

<P><IMG SRC="example1.gif" HEIGHT=133 WIDTH=490></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>example:
in step1:　D(C) ← D(D) + c(D,C)<BR>
　　　　　　　　　　 1+3<BR>
<IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14>for each column, last
entry gives immediae neighbor along least<BR>
　cost path to/from A, and cost to that destination<BR>
<IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14>worst case running
time: O(n<SUP>2</SUP>) per source node</FONT></P>

<P><FONT SIZE=+1>當A做完 Dijkstra's algorithm 後，它便會更新它的 routing
table<BR>
成為：</FONT></P>

<UL>
<TABLE BORDER=1 >
<TR>
<TD><FONT SIZE=+1>目的地</FONT></TD>

<TD><FONT SIZE=+1>下一站</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>B</FONT></TD>

<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>B</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>C</FONT></TD>

<TD><FONT SIZE=+1>D</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>D</FONT></TD>

<TD><FONT SIZE=+1>D</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD><FONT SIZE=+1>E</FONT></TD>

<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>D</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>F</FONT></TD>

<TD><FONT SIZE=+1>D</FONT></TD>
</TR>
</TABLE>
</UL>

<P><IMG SRC="../../gif/selftest.gif" HEIGHT=35 WIDTH=35>　<FONT SIZE=+1><A HREF="qa1.htm">LS
routing algorithm 如何廣播 routing 資訊</A></FONT></P>
</UL>

<P><IMG SRC="../../gif/redcube.gif" HEIGHT=18 WIDTH=18><FONT SIZE=+1>VD
Routing</FONT></P>

<UL>
<P><FONT SIZE=+1>　　LS Routing 是相當不經濟的方法，特別是網路很大時，<BR>
因為定期地廣播鏈路費用常會造成網路的壅塞（稱之為廣<BR>
播風暴（broadcast storm））。所以在大範圍的網路中，我<BR>
們通常使用非同步-分散式的 routing algorithm，稱為 vec-<BR>
tor distance routing。在 VD routing algorithm，稱為 vector dis-<BR>
tance routing。在 VD routing 中，每一 router 會在其鏈路費<BR>
用更動或 routing table 更動（因其他 router 之鏈路費用更動<BR>
造成）時，將其最新的 routing table 告訴與它相鄰的 router<BR>
（但它並不會將此資訊廣播）。在每一個 router 上，它會<BR>
維持一個二維的 distance table 以記錄目前的 routing 資訊。<BR>
如果在網路上共有 N 個 router，而此 router 與 M 個 router<BR>
相鄰，則它會維持一個 (N-1)×M 的 distance table。<BR>
例如：（圖中 distance table 是 router E 的 distance table）</FONT></P>

<P><IMG SRC="vdr.gif" HEIGHT=214 WIDTH=383></P>

<P><FONT SIZE=+1>在這個 distance table 中，記錄了</FONT></P>

<OL>
<LI><FONT SIZE=+1>從 E 到其他 router 經由不同相鄰的 router 的費用。<BR>
例如 D<SUP>E</SUP>(A,B) 是從 E 到 A 經由 B 的費用。</FONT></LI>

<LI><FONT SIZE=+1>從此 table 中， E 可以算出到其他 router 在最短路<BR>
徑的費用及經過的 router （只要看每一列中最小值<BR>
出現在哪裡）。例如，E 要到 C 的最短路徑是找<BR>
第三列中的最小值，它是 D<SUP>E</SUP>(C,D) = 4。也就是 E<BR>
到 C 最短路徑費用是 4 ，而要經過的下一個 router<BR>
是 D。</FONT></LI>

<LI><FONT SIZE=+1>得到 distance table 後，便可更新 routing table。例如<BR>
上圖中的 routing table為：</FONT></LI>
</OL>
</UL>
</UL>

<UL>
<UL>
<OL>
<OL>
<TABLE BORDER=1 >
<TR>
<TD><FONT SIZE=+1>目的地</FONT></TD>

<TD><FONT SIZE=+1>下一站</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>A</FONT></TD>

<TD><FONT SIZE=+1>A</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>B</FONT></TD>

<TD><FONT SIZE=+1>D</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>C</FONT></TD>

<TD><FONT SIZE=+1>D</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD ALIGN=CENTER VALIGN=CENTER><FONT SIZE=+1>D</FONT></TD>

<TD><FONT SIZE=+1>D</FONT></TD>
</TR>
</TABLE>
</OL>
</OL>

<P><FONT SIZE=+1>　　但是如何建立及更新 distance table 呢？我們可以使用<BR>
圖論中的分散式-非同步最短路徑演算法。其中最常用的是<BR>
distributed Bellman-Ford algorithm</FONT></P>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1>Bellman-Ford
Algorithm (at node X):</FONT></P>

<OL>
<LI><FONT SIZE=+1>Initialization:<BR>
<TT>for all adjacent nodes (column) v<BR>
　D(*,v) = ∞<BR>
　D(v,v)) = c(X,v)</TT></FONT></LI>

<LI><FONT SIZE=+1><B>loop<BR>
</B>　<TT>execute distributed topology update <BR>
　procedure<BR>
</TT><B>forever</B></FONT></LI>
</OL>

<P><IMG SRC="../../gif/gr_diam.gif" HEIGHT=19 WIDTH=19><FONT SIZE=+1>Topology
Update Algorithm</FONT></P>

<UL>
<P><FONT SIZE=+1>At node X:</FONT></P>

<OL>
<LI><FONT SIZE=+1><B>wait</B> ( until I see a link cost change to neighbor
Y,<BR>
　or until I receive control msg from neighbor W)</FONT></LI>

<LI><FONT SIZE=+1><B>if</B> (c(X,Y changes by δ)<BR>
/* change in cost to my neighbor, Y */<BR>
　change all column-Y entries in distance table by δ<BR>
　<B>if</B> this changes cost of least cost path to some node<BR>
　　, Z,send contrl message to neighbors with my new<BR>
　　minimum cost to Z</FONT></LI>

<LI><FONT SIZE=+1><B>if</B> (control msg received from my neighbor W)<BR>
/* shortest path via W to some node Z has changed */<BR>
　D<SUP>X</SUP>(Z,W) = c(X,W) + new distance from W to Z<BR>
　<B>if</B> cost of my least cost path to Z has changed send<BR>
　　control message to neighbors with my new mini-<BR>
　　mum cost to Z</FONT></LI>
</OL>
</UL>

<P><FONT SIZE=+1>例子：</FONT></P>

<UL>
<UL>
<UL>
<P><IMG SRC="bellex.gif" HEIGHT=200 WIDTH=200></P>
</UL>
</UL>

<P><IMG SRC="bellex1.gif" HEIGHT=200 WIDTH=300></P>

<P><IMG SRC="bellex2.gif" HEIGHT=200 WIDTH=300></P>

<P><IMG SRC="bellex3.gif" HEIGHT=200 WIDTH=200></P>
</UL>

<P><FONT SIZE=+1>　　VD routing 雖較適合大網路，但因其使用的是區域（local）<BR>
資訊（只有相鄰 router 之資訊），所以會造成以下兩個問題：</FONT></P>

<P><FONT SIZE=+1>(1)Looping：好消息傳的快，壞消息傳的慢。以下圖為例，<BR>
　　　　　當 (A,E) 間鏈路故障時， D 會告訴 E 要到 A 的<BR>
　　　　　費用是 3 ，於是 E 將 routing table 改成 E 到 A<BR>
　　　　　的費用是 5 ，經過的 router 是 D。E 將此消息<BR>
　　　　　告訴 D 後， D 發現它到 A 是經由 E ，而 E 到<BR>
　　　　　A 現在是 5 ，所以 D 到 A 便改為 7。D 再告訴<BR>
　　　　　E，E 又發現它到 A 是經由 D ，所以費用再改<BR>
　　　　　為 9。如此一直下去，直到很久以後 E 才會知<BR>
　　　　　道 A 須經由 B。</FONT><BR>
</P>

<UL>
<P><IMG SRC="vdfail.gif" HEIGHT=553 WIDTH=398><BR>
<BR>
<BR>
<FONT SIZE=+1><FONT COLOR="#FF0000">解決方法</FONT>：最常用的方法有兩種：<BR>
(a) split horizon：以上例而言，如果 D 到 A 的最短路徑<BR>
　　　　　　　是經由 E，則 D 必須告訴 E，它到 A 的<BR>
　　　　　　　費用是無限大。<BR>
(b) hold down：當最短路徑改變時，不要馬上反應給其他<BR>
　　　　　　　router。以上例而言，當 E 發現 A 是無限<BR>
　　　　　　　大時，它應將 A 的最短路徑改為由 D 到<BR>
　　　　　　　A ，費用為 5 。但此時，它要先告訴 D它<BR>
　　　　　　　到 A 的最短路徑是無限大。等一段時間後<BR>
　　　　　　　，再依相當情況決定短路徑。</FONT></P>
</UL>

<P><FONT SIZE=+1>(2) Oscillations：當鏈路費用是以資料流量大小而定時，會造成<BR>
　　　　　　　最短路徑一直更動。例如：</FONT></P>

<P><IMG SRC="oscillation.gif" HEIGHT=700 WIDTH=400></P>

<P><FONT SIZE=+1><FONT COLOR="#FF0000">解決方法</FONT>：(1) 不要定期地交換
routing 資訊</FONT></P>

<P><FONT SIZE=+1>　　　　　(2) 不要讓鏈路費用與以流量大小成正比</FONT></P>
</UL>
</UL>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD COLSPAN="3"><B><FONT COLOR="#FFFFFF"><FONT SIZE=+2>階層式網路架構　　　　　　　　　　　　　　　</FONT></FONT></B></TD>
</TR>
</TABLE>

<UL>
<P><FONT SIZE=+1>　　雖然透過 router 將區域網路連接後，便可形成廣域網路，但事<BR>
實上 router 還是有分兩個層次的。一般而言，廣域網路是由公共網<BR>
路（public network ）串連許多私人網路（private network）而形成。<BR>
例如目前台灣學術網路是由 7 個網路節點（區域網路中心）所形成<BR>
的骨幹網路（即公用網路）來串連分布在各地的私人網路（例如中<BR>
正大學校園網路）。在私人網路中，是由第一層次的 router （Inter-<BR>
net 稱之為 Interior Gateway）串連許多區域網路所形成。而從私人<BR>
網路連上骨幹網路的 router 則是屬於第二層次的 router（Internet 稱<BR>
之為 Exterior Gateway）。以中正大學校園網路為例：</FONT></P>
</UL>

<P><IMG SRC="gateway.gif" HEIGHT=500 WIDTH=600></P>

<TABLE BGCOLOR="#FF0000" >
<TR>
<TD COLSPAN="3"><B><FONT COLOR="#FFFFFF"><FONT SIZE=+2>不同層次的 routing　　　　　　　　　　　　　　　</FONT></FONT></B></TD>
</TR>
</TABLE>

<UL>
<TABLE BGCOLOR="#0000FF" >
<TR>
<TD COLSPAN="3"><IMG SRC="../../gif/cy_ball.gif" HEIGHT=16 WIDTH=17><B><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Host
與 Interior Gateway</FONT></FONT></B></TD>
</TR>
</TABLE>

<P><FONT SIZE=+1>　　依 IP 的 routing 規定，Host 與 Interior Gateway 間的
routing 是相當<BR>
簡單的。一台 host 必須手動地輸入一個 netmask 以決定哪些 IP address<BR>
是與此台機器同屬一區域網路。例如 140.123.101.100 這台機器的 net-<BR>
mask 如果是 255.255.255.0 ，則所有 IP address 是以 140.123.101 開頭的<BR>
機器均是屬於同一區域網路。另在每台 host 還需輸入一台以上同屬於一<BR>
區域網路的 Interior gateway 的位置，例如：140.123.101.250。在每一台<BR>
host 的 routing table 上，則可記錄要到哪一 subnet 須走哪一台 Interior <BR>
gateway。在 routing table 中，還可定義 default 的 Interior gateway 以免需<BR>
要輸入太多的 routing table entry。（在 UNIX 以下，你可利用 &quot;netstat
-r&quot;<BR>
來看目前的 routing table 的設定）。當 host 有一 packet 要送時，首先 IP<BR>
會 check 此 packet 的目的地 是否與 source 是在同一區域網路，是的話<BR>
則直接送給第二層送到 LAN 上。否則，依目的地的 IP 位址查 routing <BR>
table 以得知要由哪一個 Interior gateway 來轉送，然後通知第二層將 packet<BR>
送給這個 gateway 。Interior Gateway 則必須在 routing table 中記錄它所<BR>
直接連接的（即所服務的）區域網路有哪些。</FONT></P>

<TABLE BGCOLOR="#0000FF" >
<TR>
<TD COLSPAN="3"><IMG SRC="../../gif/cy_ball.gif" HEIGHT=16 WIDTH=17><B><FONT COLOR="#FFFFFF"><FONT SIZE=+1>
Interior Gateway間之routing</FONT></FONT></B></TD>
</TR>
</TABLE>

<P><FONT SIZE=+1>　　只有在同一權責單位（administrative domain）內的 Interior
Gateway<BR>
才可以彼此交換 routing 資訊。通常我們將此一種權責單位稱之為 domain<BR>
或 Autonomous System (AS)。例如中正大學校園內稱之為 domain (AS)。<BR>
目前中正大學內約有 20 個 Interior Gateway，例如在本系 401 主機房就有<BR>
一顆 Interior Gateway 連接資工和電機的區域網路。中正大學校園主幹網<BR>
路架構圖請參考電算中心姜自強先生的網頁（
<A HREF="http://www.ccunix.ccu.edu.tw/~steve/jobs-txt/jobs-hp.html" target="top">
http://www.ccunix.ccu.edu.<BR>
tw/~steve/jobs-txt/jobs-hp.html</A>）。所以凡是封包目的地不在 source<BR>
的區域網路內，但是在同一 domain 內時，此封包便由 interior gateway <BR>
來進行路徑選擇的工作。在所有的 Interior gateway 中，至少有一顆是兼<BR>
任 Exterior Gateway。其他 Interior gateway 不會去要求與此 Exterior gate-<BR>
way 交換有關 domain 外的 routing 的資訊。所有要出此 domain 的封包均<BR>
由 Interior gateway 直接轉給 Exterior gateway ，再由 Exterior Gateway 去<BR>
決定路徑的選擇。所以一個 Interior gateway 只需知道它所服務的區域網<BR>
路有哪些，同一 domain 內的其他 Interior gateway 的 routing 資料，以及<BR>
此 domain 內的 Exterior gateway 在哪裡。</FONT></P>

<P><FONT SIZE=+1>　　因為一個 domain 通常範圍較小，且同屬同一權責單位，所以
Interior<BR>
gateway 間的 routing algorithm 通常是使用 Link-State routing 的方法。目前<BR>
Internet 的 Interior gateway 常使用的 routing protocol 有：</FONT></P>

<UL>
<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>Routing
Information Protocol (RIP)</FONT></P>

<UL>
<P><FONT SIZE=+1>此 protocol 是由 Xerox PARC 的 Universal Protocol 演變而來，<BR>
目前 BSD UNIX 的 routed 即是使用 RIP 為 routing protocol 。<BR>
它是屬於 vector distance routing algorithm，鏈路費用是每一條<BR>
鏈路均設為 1 。（所以最短路徑就是含最少鏈路的路徑。）</FONT></P>
</UL>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>Interior
Gateway Routing Protocol (IGRP)</FONT></P>

<UL>
<P><FONT SIZE=+1>此 protocol 是由 cisco 在 1980 年中所提出。後來在 1990
年初<BR>
改為 Enhanced IGRP。它也是屬於 vector distance routing protocol<BR>
，鏈路費用則分四類（delay, bandwidth, reliability, load），它<BR>
同時支援多路徑傳送（multi path routing）的功能。</FONT></P>
</UL>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>Open
Shortest Path FIrst (OSPF)</FONT></P>

<UL>
<P><FONT SIZE=+1>OSPF 是目前 Internet 想推動的 routing protocol（RFC 1247）。<BR>
它採開放式系統（open）及 Dijkstra 的 shortest path algorithm（<BR>
SPF）。也就是說它是屬於 LS routing。鏈路費用支援 IP 的 type<BR>
of service（含 delay, throughput, reliability）。為支援 IP 的 TOS<BR>
，它可以同時維護 8 個 routing tables（因共有八種 TOS 的組合<BR>
）。</FONT></P>
</UL>
</UL>

<TABLE BGCOLOR="#0000FF" >
<TR>
<TD COLSPAN="3"><IMG SRC="../../gif/cy_ball.gif" HEIGHT=16 WIDTH=17><B><FONT COLOR="#FFFFFF"><FONT SIZE=+1>Exterior
Gateway 間之 routing</FONT></FONT></B></TD>
</TR>
</TABLE>

<P><FONT SIZE=+1>　　Exterior Gateway 因屬於不同的權責單位，解範圍廣大，所以所遭遇<BR>
的問題也比較多。有時我們也稱 Exterior Gateway 為 Border Gateway，因<BR>
它就像我們機場的出入境管理一樣。 Exterior Gateway 與 Exterior Gateway<BR>
間使用自己的 routing protocol ，一般不會與 Interior Gateway 交換這一層<BR>
的 routing information。在這一層比較麻煩的是 routing 是 policy dependent<BR>
，也就是說每個 domain 有權決定如何來 forward 一個封包到另一個 exterior<BR>
gateway。不同的 domain 因此會有不同的 policy（例如軍方會考慮國防機<BR>
密）。在 Exterior Gateway 的 routing 中，彼此之間的連線是以邏輯的眼光<BR>
來看，因為他們不想管 domain 內的 routing。例如：</FONT></P>

<UL>
<UL>
<P><IMG SRC="interroute1.gif" HEIGHT=318 WIDTH=330></P>

<P><IMG SRC="interroute2.gif" HEIGHT=277 WIDTH=314></P>

<P><FONT SIZE=+1>以上圖為例，如果 D4 要送 packet 給 C3，則：</FONT></P>
</UL>
</UL>
</UL>

<P><IMG SRC="osiroute.gif" HEIGHT=238 WIDTH=552></P>

<UL>
<P><FONT SIZE=+1>目前常見的 Exterior Gateway 間的 routing protocol 有：</FONT></P>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>Exterior
Gateway Protocol (EGP)</FONT></P>

<UL>
<P><FONT SIZE=+1>這是 1980 年代 Internet 最常用的 interdomain routing protocol<BR>
。它只維持網路連接資訊（network reachability information）<BR>
，沒有鏈路費用的觀念也沒有任何智慧型演算法。</FONT></P>
</UL>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>Border
Gateway Protocol (BGP)</FONT></P>

<UL>
<P><FONT SIZE=+1>這是比較新的 protocol，屬於 vector distance routing protocol<BR>
algorithm 且支援不同鏈路費用的組合。</FONT></P>
</UL>

<P><IMG SRC="../../gif/orangeba.gif" HEIGHT=14 WIDTH=14><FONT SIZE=+1>Interdomain
Routing Protocol (IDRP)</FONT></P>

<UL>
<P><FONT SIZE=+1>IDRP 是 ISO 最新所提出來的 routing protocol。它也是使用<BR>
vector distance routing algorithm，且支援 policy dependent<BR>
routing。</FONT></P>
</UL>
</UL>

<TABLE BORDER=1 >
<TR>
<TD><FONT SIZE=+1><A HREF="rt_mcast.html">For More Information</A></FONT></TD>
</TR>

<TR>
<TD><FONT SIZE=+1>　　Routing 看起來簡單，事實上每個 routing protocol 均很複雜，router<BR>
上的 command 及 configuration 更是非專業人才無法了解。在此我們提<BR>
供了另一網頁來作更詳細的介紹。你也可以連到 Cisco，3Com 等做rout-<BR>
er 的公司的網頁去瀏覽他們的介紹。我們也提供了 RFC 的連結，讓你<BR>
可以直接看到詳細的 protocol 規格。</FONT></TD>
</TR>
</TABLE>

</BODY>
</HTML>
